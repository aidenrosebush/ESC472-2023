# -*- coding: utf-8 -*-
"""Viewshed_LOS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/aidenrosebush/ESC472-2023/blob/main/Viewshed_LOS.ipynb
"""

import tcod
import numpy as np
import matplotlib.pyplot as plt

def getTestPoints(map, point, direction, r):
  testPoints = [] #points on the same side as the ad is facing
  for i in range(0, len(map), 1): 
    for j in range(0, len(map[0]), 1):
      relativeTestPoint = np.array([i-point[0],j-point[1]])
      #if the point is on the right side of the billboard and is within visible range
      if np.dot(relativeTestPoint, direction) >= 0 and np.sqrt(np.dot(relativeTestPoint, relativeTestPoint)) <= r:
        testPoints += [np.array([i,j])]
  return testPoints
def plotTestPoints(map, testPoints):
  fig, ax = plt.subplots()
  coloredMap = np.zeros((len(map), len(map[0])))
  for testPoint in testPoints:
    coloredMap[testPoint[0], testPoint[1]] = 1
  ax.imshow(coloredMap)
  ax.set_title('Test Points')
  return
def plotMap(map):
  fig, ax = plt.subplots()
  im = ax.imshow(map)
  ax.set_title('Elevation Map')
  fig.colorbar(im, ax=ax, label='Elevation')
def fitSightLine(map, point, testPoint, elevation):
  # y-y0 = m*(r)
  m = (map[testPoint[0]][testPoint[1]]-elevation)/(np.sqrt(sum((point-testPoint)**2)))
  return m
def getViewshed(map, point, direction, r, elevation):
  point = np.array(point)
  t = getTestPoints(map, point, direction, r)
  plotMap(map)
  plotTestPoints(map, t)
  line = []
  visiblePoints = [point]

  for testPoint in t:
    if testPoint[0] != point[0] or testPoint[1] != point[1]: #don't consider the ad location itself
      elevations = []
      line = tcod.los.bresenham(point,testPoint) #get grid coordinates to search through
      max = -1 #elevation data must bottom out at 0
      m = 0 #store slope of top sightline
      m_test = 0 #store slope of sightline of test point when the test point is not above any point yet seen
      m = fitSightLine(map, point, line[1], elevation)
      visiblePoints += [line[1]]
      for i in range(2, len(line), 1):
        m_test = fitSightLine(map, point, line[i], elevation)
        if m_test >= m:
          m = m_test
          visiblePoints += [line[i]]
  return visiblePoints
def plotVisiblePoints(map, visiblePoints):
  fig, ax = plt.subplots()
  coloredMap = np.zeros((len(map), len(map[0])))
  for point in visiblePoints:
    coloredMap[point[0], point[1]] = 1
  ax.imshow(coloredMap)
  ax.set_title('Visible Points')
  return
def addBuildingSquare(map, x_left,x_right,y_bottom,y_top, height):
  for x in range(x_left,x_right,1):
    for y in range(y_bottom, y_top, 1):
      map[x][y] = height
  return map

if __name__=="__main__":
  from pyproj import Transformer
  import copy
  import convertShp2Array as shp2array
  """
  wmerc refers to webmercator or wgs84 psuedo mercator, EPSG3857
  utm refers to wgs84 utm 17N, EPSG32617
  the building height file uses the pseudo mercator co-ordinate reference system (crs)
  the terrain file uses utm as its crs
  """

  scale = 10

  wmerc2utm = Transformer.from_crs("EPSG:3857","EPSG:32617")
  utm2wmerc = Transformer.from_crs("EPSG:32617","EPSG:3857")

  centre_wmerc = [-8837768.68,5410177.27]

  centre_utm = wmerc2utm.transform(*centre_wmerc)
  radius_utm = 250
  bbox_utm = shp2array.Bbox(centre_utm, radius_utm)

  bbox_wmerc = copy.copy(bbox_utm)
  bbox_wmerc.transform( utm2wmerc.transform )

  building_array = shp2array.import_shpfile_as_array("./toronto_3d_massing/3DMassingShapefile_2022_WGS84.shp", "AVG_HEIGHT", bbox_wmerc, nrows=scale*20, ncols=scale*20)
  dtm_array = shp2array.import_tif_as_array("./dtm_1m_utm17_e_12_83.tif",bbox_utm, nrows=scale*20, ncols=scale*20)

  map = building_array + dtm_array

  point = [scale*16,scale*3]
  direction = [-1,1]
  r = 3*scale
  elevation = 15
  m = getViewshed(map, point, direction, r, elevation)
  plotVisiblePoints(map, m)
  plt.show()
